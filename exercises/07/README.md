Упражнение 7
============

[Binary Heap (a.k.a Priority Queue)](https://en.wikipedia.org/wiki/Binary_heap)
------------------------------------

**def.** **Min**-heap е двоична пирамида,
при която всеки връх в нея е **по-малък** от децата си.

**def.** **Max**-heap е двоична пирамида,
при която всеки връх в нея е **по-голям** от децата си.

Задачи
------

1. Реализирайте функцията `void heapSort(const vector<int>& numbers)`,
която сортира редицата от числа `numbers`,
използвайки двоична пирамида за целта.
Каква времева сложност има вашия алгоритъм?

2. Реализирайте функцията `void kthSmallest(const vector<int>& numbers)`,
която намира k-тия най-малък елемент в редицата от числа `numbers`.
Каква времева сложност има вашия алгоритъм?

3. Реализирайте стуктура от данни `Median`,
която съхранява редица от елементи и може да намира медианата на редицата.
Трябва да поддържа следните 2 операции:

   - `void insert(T item)`, която вмъква елемент

   - `T median()`, която намира медианата на редицата

   Каква времева сложност имат двете операции във вашата реализация?

   Каква е сложността по памет?

   Как бихте оптимизирали вашето решение с приоритетна опашка?

   **def. Медиана** на редица от числа `[a1, a2, ..., aN]` с N елемента e средата на сортираната редица:

   - когато `N` е нечетно число, медианата е средният елемент на позиция `N / 2` в сортираната редица.

   - когато `N` е четно число, медианата е средно-аритметичното на двата средни елемента в сортираната редица.

      Например, медианата на редицата `[8, 4, 9, 2, 2, 3, 1, 13]` е `3.5`,
      защото двата средни елемента в сортираната редица са `3` и `4` - [1, 2, 2, **3**, **4**, 8, 9, 13].

4. Реализирайте функцията `std::vector<int> sortedMerge(std::vector<std::vector<int>> vectors)`,
която получава редица от К на брой сортирани редици `vectors` и
слива всички сортирани редици, за да върне една сортирана редица с всички елементи.
Каква времева сложност има вашия алгоритъм?
