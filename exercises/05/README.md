Упражнение 5
============

Задачи
------

1. Реализирайте функцията `int sum(BTree* tree)`,
която намира сумата на всички върхове в дървото `tree`.

    Например сумата на следното дърво е `50`:
    ```
          10
        /   \
       4     15
      / \   /
     1   8 12
    ```

2. Реализирайте предиката `bool isBinarySearchTree(const BTree* tree)`,
който проверява дали дървото `tree` е двоично наредено дърво за търсене.

3. Реализирайте предиката `bool isBalanced(const BTree* tree)`,
който проверява дали дървото `tree` е балансирано.
Какъв порядък от операции извършвате спрямо големината на дървото `n`?
Направете решение, което извършва `O(n)` операции.

   - `def` Дърво е **балансирано**, когато за всеки връх в дървото е изпълнено,
   че височините на под-дърветата на върха се различават най-много с 1.

4. Реализирайте функцията `BTree* toBalancedTree(const std::vector<int>& numbers)`,
която приема **сортирана** редица с **уникални** числа `numbers` и
построява балансирано двоично наредено дърво от редицата.

    Например, редицата `[1, 2, 3, 4, 5, 6]` се свежда до следното дърво:
    ```
          4
        /   \
       2     6
      / \   /
     1   3 5
    ```


5. Реализирайте функцията `void invert(BTree* tree)`,
която прави огледалния образ на дървото `tree` и така обръща реда на елементите в него.

    Например:
    ```
         4                4
        / \    invert    / \
       2   5  ========> 5   2
      / \                  / \
     1   3                3   1
    ```

6. Реализирайте функцията `BTree* lowestCommonAncestor(BTree* root, BTree* a, BTree* b)`,
която намира най-близкия общ предшественик на двата върха `a` и `b` в двоичното дърво с корен `root`.

    Например, нека е дадено дървото:
    ```
          10
        /   \
       7     13
      / \   /
     1   9 12
        /
       8
    ```

    Тогава най-близкият общ предшественик на върховете `1` и `8` е `7`, а на `9` и `13` е `10`:

7. Реализирайте функцията `std::vector<int> rightSideView(BTree* root)`,
която намира елементите на дървото, които се виждат, гледайки дървото отдясно.

    Например, нека е дадено следното дърво:
    ```
          10    <--
        /   \
       7     13 <--
      / \   /
     1   9 12   <--
        /
       8        <--
    ```
    Като погледнем дървото от дясно, ще видим елементите `10`, `13`, `12` и `8`.
