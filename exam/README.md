Контролно
---------

**Задача 1.** (10 точки)
Нека е дадена структурата от данни за възел в линеен едносвързан списък:

```cpp
struct ListNode {
    int value;
    ListNode *next;
};
```

Да се реализира функция
`[подходящ тип] combine([подходящ тип] odds, [подходящ тип] evens)`,
която приема главите на линейните едносвързани списък `odds` и `evens`.

Функцията връща главата на нов линеен едносвързан списък,
който е с дължината на по-малкия от двата списъка и
на четните позиции има елементите на четните позиции в `evens`,
а на нечетните позиции има елементите на нечетните позиции в `odds`.

Пример:

   Ако `odds` = [**1**, 2, **3**, 4, 5], а `evens` = [5, **6**, 19, **15**],
   то резултатът от `combine(odds, evens)` ще бъде `[1, 6, 3, 15]`.


**Задача 2.** (10 точки)
Нека е дадена структурата от данни за възел в линеен едносвързан списък:

```cpp
struct ListNode {
    int value;
    ListNode *next;
};
```

Да се реализира функция
`void removeDuplicates([подходящ тип] l)`,
която приема главата на линеен едносвързан списък `l`
и премахва дублиращите се елементи от него.

Примери:

   Ако `l = [1, 1, 31, 5, 5, 5, 12, 13]`, то след изпълнението на
   `removeDuplicates(l)` `l` ще бъде `[1, 31, 5, 12, 13]`.

   Ако `l = [6, 6, 6, 6, 6]`, то след изпълнението на
   `removeDuplicates(l)` `l` ще бъде `[6]`.

* **Бонус.** (5 точки)
Направете линейно решение. Позволено Ви е да ползвате `STL`.


**Задача 3.** (10 точки)

**def.** Двоично дърво може да се **сгъне**, ако е празното дърво или ако
лявото поддърво на корена е огледален образ на дясното поддърво на корена.

Нека е дадена структура, която описва възел в двоично дърво:

```cpp
struct TreeNode {
    int value;
    TreeNode *left;
    TreeNode *right;
};
```

Да се дефинира функция
`bool isFoldable([подходящ тип] t)`,
която проверява дали двоичното дърво `t` може да се **сгъне**.

Примери:

(a) пример за сгъваемо дърво
```
   10
 /    \
7      15
 \    /
  9  11
```

(b) пример за сгъваемо дърво
```
    10
   /  \
  7    15
 /      \
9       11
```


(c) пример за **НЕ**сгъваемо дърво
```
    10
   /  \
  7   15
 /    /
9   11
```

(d) пример за **НЕ**сгъваемо дърво
```
     10
   /   \
  7     15
 /  \    /
9   10  12
```


**Задача 4.** (10 точки)

Да се реализира функция
`[подходящ тип] pathExists([подходящ тип] g, [подходящ тип] a, [подходящ тип] b)`,
която проверява дали съществува път от връх `a` до връх `b` в граф `g`.

Върховете можете да представите като последователни цели числа.
Графът може да се представи по Ваш избор за Ваше улесенение, например като
матрица на съседство или списък на съседство на върховете.

Примери:

   Ако графът g е списъкът на съседство
   `[0 -> [1, 3], 1 -> [4, 2], 2 -> [3, 0], 3 -> [], 4 -> []]`,
   `a = 1`, `b = 3`, тогава `pathExists(g, a, b)` връща истина.
   Но `pathExists(g, 2, 3)` връща лъжа.

* **Бонус.** (5 точки) Направете функцията така, че да работи за графи с **цикли**.

* **Бонyс.** (7 точки) Модифицирайте функцията `pathExists`, така че
да построява пълен път от връх `a` до връх `b`, ако такъв съществува.
По Ваш избор функцията може да връща редицата от възлите в пътя
или за целта да добавите четвърти аргумент към функцията с подходящ тип.
Може да има няколко пътя. Върнете един от тях.

Пример:

   Ако графът g е списъкът на съседство
   `[0 -> [1, 2], 1 -> [2], 2 -> [3], 3 -> [4, 1], 4 -> [1]]`,
   тогава `pathExists(g, 0, 4)` построява пътя `[0, 2, 3, 4]`.
